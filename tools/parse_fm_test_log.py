"""Parse DCS log file for MiG-17 flight model test results.

This script extracts and analyzes data from the [MIG17_FM_TEST] log entries
generated by the FM test mission. It compares measured performance against
historical MiG-17F targets and generates a verification report.

Multi-FM Mode:
    Parses group names with variant prefixes (e.g., FM6_VMAX_10K) and
    aggregates results by variant. Each variant gets its own section in
    the output report.

Single-FM Mode (backwards compatible):
    Old logs without prefixes are treated as variant "FM0" with the
    original group names as test names.

Usage:
    python parse_fm_test_log.py [--log-file PATH] [--output PATH] [--csv PATH]

If --log-file is not specified, searches common DCS log locations.
"""
from __future__ import annotations

import argparse
import csv
import logging
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

LOGGER = logging.getLogger(__name__)

# Historical MiG-17F performance targets
TARGETS = {
    "vmax_sl_kt": 593,      # Max speed at sea level (1100 km/h)
    "vmax_10k_kt": 618,     # Max speed at 10,000 ft with AB (1145 km/h)
    "roc_fpm": 12800,       # Rate of climb (65 m/s)
    "ceiling_ft": 54500,    # Service ceiling
}

# MiG-17F weight and fuel specifications (from mig17f.lua)
MIG17_SPECS = {
    "empty_kg": 3920,       # Empty weight with pilot (M_empty)
    "nominal_kg": 5345,     # Empty + full internal fuel (M_nominal)
    "max_kg": 6075,         # Maximum takeoff weight (M_max)
    "fuel_max_kg": 1140,    # Internal fuel capacity (M_fuel_max)
    "thrust_mil_kgf": 2650,     # Military power thrust
    "thrust_ab_kgf": 3380,      # Afterburner thrust
    "fuel_ratio_ab": 2.06,      # Afterburner fuel consumption ratio vs military
}

# Acceptable tolerance for pass/fail (percentage)
TOLERANCE_PCT = 5.0

# Default variant key for old logs without prefixes
DEFAULT_VARIANT = "FM0"


@dataclass
class SpeedGate:
    """Record of crossing a speed gate."""

    gate_kt: float
    elapsed_s: float
    alt_ft: float


@dataclass
class AltGate:
    """Record of crossing an altitude gate."""

    gate_ft: float
    elapsed_s: float
    climb_rate_fpm: float


@dataclass
class GroupResult:
    """Collected results for a single test group."""

    name: str
    variant_key: str = DEFAULT_VARIANT
    test_name: str = ""
    start_alt_ft: float = 0
    start_spd_kt: float = 0
    max_spd_kt: float = 0
    max_alt_ft: float = 0
    max_vspd_fpm: float = 0
    speed_gates: list[SpeedGate] = field(default_factory=list)
    alt_gates: list[AltGate] = field(default_factory=list)
    vmax_kt: Optional[float] = None
    vmax_alt_ft: Optional[float] = None
    vmax_mach: Optional[float] = None
    # Ceiling test results
    ceiling_alt_ft: Optional[float] = None
    ceiling_roc_fpm: Optional[float] = None
    ceiling_mach: Optional[float] = None
    # Fuel tracking
    start_fuel_kg: Optional[float] = None
    start_fuel_pct: Optional[float] = None
    start_weight_kg: Optional[float] = None
    end_fuel_kg: Optional[float] = None
    fuel_used_kg: Optional[float] = None


def parse_group_name(full_name: str) -> tuple[str, str]:
    """Parse a group name into variant key and test name.

    Multi-FM group names have the format: FM<N>_<TEST_NAME>
    Reference aircraft have format: PREFIX_<TEST_NAME>
    Old single-FM group names have no prefix.

    Args:
        full_name: The full group name from the log

    Returns:
        Tuple of (variant_key, test_name)

    Examples:
        "FM6_VMAX_10K" -> ("FM6", "VMAX_10K")
        "FM0_ACCEL_SL" -> ("FM0", "ACCEL_SL")
        "MIG15_VMAX_SL" -> ("MIG15", "VMAX_SL")
        "F86_CLIMB_SL" -> ("F86", "CLIMB_SL")
        "MIG19_ACCEL_10K" -> ("MIG19", "ACCEL_10K")
        "MIG21_VMAX_10K" -> ("MIG21", "VMAX_10K")
        "VMAX_10K" -> ("FM0", "VMAX_10K")  # backwards compatibility
    """
    # Check for FM<digit> prefix pattern
    match = re.match(r"^(FM\d+)_(.+)$", full_name)
    if match:
        return match.group(1), match.group(2)

    # Check for reference aircraft prefixes
    ref_match = re.match(r"^(MIG15|F86|MIG19|MIG21)_(.+)$", full_name)
    if ref_match:
        return ref_match.group(1), ref_match.group(2)

    # No prefix - treat as default variant
    return DEFAULT_VARIANT, full_name


def find_dcs_log() -> Optional[Path]:
    """Search common locations for the DCS log file."""
    candidates = [
        Path.home() / "Saved Games" / "DCS" / "Logs" / "dcs.log",
        Path.home() / "Saved Games" / "DCS.openbeta" / "Logs" / "dcs.log",
        Path.home() / "Saved Games" / "DCS.release_server" / "Logs" / "dcs.log",
    ]
    for path in candidates:
        if path.exists():
            return path
    return None


def parse_log_file(log_path: Path) -> dict[str, dict[str, GroupResult]]:
    """Parse the DCS log file and extract FM test data.

    Returns:
        Nested dict: results[variant_key][test_name] -> GroupResult
    """
    # Flat storage keyed by full group name for parsing
    flat_results: dict[str, GroupResult] = {}
    pattern = re.compile(r"\[MIG17_FM_TEST\]\s+(.+)")

    content = log_path.read_text(encoding="utf-8", errors="ignore")

    for line in content.splitlines():
        match = pattern.search(line)
        if not match:
            continue

        data = match.group(1).strip()

        # Parse START lines: START,<group>,alt=<alt>,spd=<spd>[,fuel_kg=,fuel_pct=,weight_kg=]
        if data.startswith("START,"):
            parts = data.split(",")
            if len(parts) >= 2:
                group_name = parts[1]
                if group_name not in flat_results:
                    variant_key, test_name = parse_group_name(group_name)
                    flat_results[group_name] = GroupResult(
                        name=group_name,
                        variant_key=variant_key,
                        test_name=test_name,
                    )
                # Extract fields from key=value pairs
                for part in parts[2:]:
                    if part.startswith("alt="):
                        flat_results[group_name].start_alt_ft = float(part[4:])
                    elif part.startswith("spd="):
                        flat_results[group_name].start_spd_kt = float(part[4:])
                    elif part.startswith("fuel_kg="):
                        flat_results[group_name].start_fuel_kg = float(part[8:])
                    elif part.startswith("fuel_pct="):
                        flat_results[group_name].start_fuel_pct = float(part[9:])
                    elif part.startswith("weight_kg="):
                        flat_results[group_name].start_weight_kg = float(part[10:])

        # Parse SPEED_GATE lines: SPEED_GATE,<group>,<gate_kt>,<elapsed_s>,<alt_ft>
        elif data.startswith("SPEED_GATE,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in flat_results:
                    variant_key, test_name = parse_group_name(group_name)
                    flat_results[group_name] = GroupResult(
                        name=group_name,
                        variant_key=variant_key,
                        test_name=test_name,
                    )
                gate = SpeedGate(
                    gate_kt=float(parts[2]),
                    elapsed_s=float(parts[3]),
                    alt_ft=float(parts[4]),
                )
                flat_results[group_name].speed_gates.append(gate)

        # Parse ALT_GATE lines: ALT_GATE,<group>,<gate_ft>,<elapsed_s>,<climb_rate_fpm>
        elif data.startswith("ALT_GATE,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in flat_results:
                    variant_key, test_name = parse_group_name(group_name)
                    flat_results[group_name] = GroupResult(
                        name=group_name,
                        variant_key=variant_key,
                        test_name=test_name,
                    )
                gate = AltGate(
                    gate_ft=float(parts[2]),
                    elapsed_s=float(parts[3]),
                    climb_rate_fpm=float(parts[4]),
                )
                flat_results[group_name].alt_gates.append(gate)

        # Parse VMAX lines: VMAX,<group>,<speed_kt>,<alt_ft>,<mach>
        elif data.startswith("VMAX,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in flat_results:
                    variant_key, test_name = parse_group_name(group_name)
                    flat_results[group_name] = GroupResult(
                        name=group_name,
                        variant_key=variant_key,
                        test_name=test_name,
                    )
                flat_results[group_name].vmax_kt = float(parts[2])
                flat_results[group_name].vmax_alt_ft = float(parts[3])
                flat_results[group_name].vmax_mach = float(parts[4])

        # Parse CEILING lines: CEILING,<group>,<alt_ft>,<roc_fpm>,<mach>
        elif data.startswith("CEILING,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in flat_results:
                    variant_key, test_name = parse_group_name(group_name)
                    flat_results[group_name] = GroupResult(
                        name=group_name,
                        variant_key=variant_key,
                        test_name=test_name,
                    )
                flat_results[group_name].ceiling_alt_ft = float(parts[2])
                flat_results[group_name].ceiling_roc_fpm = float(parts[3])
                flat_results[group_name].ceiling_mach = float(parts[4])

        # Parse SUMMARY lines: SUMMARY,<group>,<max_spd>,<max_alt>,<max_vspd>[,fuel_start=,fuel_end=,fuel_used=]
        elif data.startswith("SUMMARY,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in flat_results:
                    variant_key, test_name = parse_group_name(group_name)
                    flat_results[group_name] = GroupResult(
                        name=group_name,
                        variant_key=variant_key,
                        test_name=test_name,
                    )
                flat_results[group_name].max_spd_kt = float(parts[2])
                flat_results[group_name].max_alt_ft = float(parts[3])
                flat_results[group_name].max_vspd_fpm = float(parts[4])
                # Parse optional fuel fields
                for part in parts[5:]:
                    if part.startswith("fuel_start="):
                        flat_results[group_name].start_fuel_kg = float(part[11:])
                    elif part.startswith("fuel_end="):
                        flat_results[group_name].end_fuel_kg = float(part[9:])
                    elif part.startswith("fuel_used="):
                        flat_results[group_name].fuel_used_kg = float(part[10:])

    # Reorganize into nested structure: results[variant_key][test_name]
    results: dict[str, dict[str, GroupResult]] = {}
    for group_result in flat_results.values():
        variant_key = group_result.variant_key
        test_name = group_result.test_name
        if variant_key not in results:
            results[variant_key] = {}
        results[variant_key][test_name] = group_result

    return results


def check_tolerance(measured: float, target: float, tolerance_pct: float) -> bool:
    """Check if measured value is within tolerance of target."""
    if target == 0:
        return measured == 0
    deviation_pct = abs(measured - target) / target * 100
    return deviation_pct <= tolerance_pct


def format_fuel_info(result: GroupResult) -> list[str]:
    """Format fuel information for a test result."""
    lines: list[str] = []
    if result.start_fuel_kg is not None:
        lines.append(f"  Start fuel:   {result.start_fuel_kg:.0f} kg")
        if result.start_fuel_pct is not None:
            lines[-1] += f" ({result.start_fuel_pct:.0f}%)"
    if result.start_weight_kg is not None:
        lines.append(f"  Start weight: {result.start_weight_kg:.0f} kg")
    if result.fuel_used_kg is not None and result.fuel_used_kg > 0:
        lines.append(f"  Fuel used:    {result.fuel_used_kg:.0f} kg")
    return lines


def generate_variant_section(
    variant_key: str,
    variant_results: dict[str, GroupResult],
) -> tuple[list[str], bool]:
    """Generate report section for a single variant.

    Returns:
        Tuple of (lines, all_pass)
    """
    lines: list[str] = []
    all_pass = True

    lines.append("")
    lines.append("=" * 70)
    lines.append(f"=== Variant {variant_key} ===")
    lines.append("=" * 70)

    # Vmax at sea level
    lines.append("-" * 70)
    lines.append("VMAX_SL - Maximum Speed at Sea Level")
    lines.append("-" * 70)
    if "VMAX_SL" in variant_results:
        r = variant_results["VMAX_SL"]
        measured = r.vmax_kt or r.max_spd_kt
        target = TARGETS["vmax_sl_kt"]
        passed = check_tolerance(measured, target, TOLERANCE_PCT)
        status = "PASS" if passed else "FAIL"
        all_pass = all_pass and passed
        lines.append(f"  Measured: {measured:.1f} kt")
        lines.append(f"  Target:   {target} kt")
        lines.append(f"  Status:   {status}")
        if r.vmax_mach:
            lines.append(f"  Mach:     {r.vmax_mach:.3f}")
        lines.extend(format_fuel_info(r))
    else:
        lines.append("  No data available")
        all_pass = False
    lines.append("")

    # Vmax at 10,000 ft
    lines.append("-" * 70)
    lines.append("VMAX_10K - Maximum Speed at 10,000 ft (with Afterburner)")
    lines.append("-" * 70)
    if "VMAX_10K" in variant_results:
        r = variant_results["VMAX_10K"]
        measured = r.vmax_kt or r.max_spd_kt
        target = TARGETS["vmax_10k_kt"]
        passed = check_tolerance(measured, target, TOLERANCE_PCT)
        status = "PASS" if passed else "FAIL"
        all_pass = all_pass and passed
        lines.append(f"  Measured: {measured:.1f} kt")
        lines.append(f"  Target:   {target} kt")
        lines.append(f"  Status:   {status}")
        if r.vmax_mach:
            lines.append(f"  Mach:     {r.vmax_mach:.3f}")
        lines.extend(format_fuel_info(r))
    else:
        lines.append("  No data available")
        all_pass = False
    lines.append("")

    # Rate of climb
    lines.append("-" * 70)
    lines.append("CLIMB_SL - Rate of Climb from Sea Level (Full Fuel, with AB)")
    lines.append("-" * 70)
    if "CLIMB_SL" in variant_results:
        r = variant_results["CLIMB_SL"]
        measured = r.max_vspd_fpm
        target = TARGETS["roc_fpm"]
        passed = check_tolerance(measured, target, TOLERANCE_PCT)
        status = "PASS" if passed else "FAIL"
        all_pass = all_pass and passed
        lines.append(f"  Max Climb Rate: {measured:.0f} fpm")
        lines.append(f"  Target:         {target} fpm")
        lines.append(f"  Status:         {status}")
        lines.extend(format_fuel_info(r))
        # Show altitude gates
        if r.alt_gates:
            lines.append("  Altitude Gates:")
            for gate in sorted(r.alt_gates, key=lambda g: g.gate_ft):
                lines.append(
                    f"    {gate.gate_ft:,.0f} ft at t={gate.elapsed_s:.1f}s "
                    f"(ROC: {gate.climb_rate_fpm:.0f} fpm)"
                )
    else:
        lines.append("  No data available")
        all_pass = False
    lines.append("")

    # Acceleration tests
    for test_name in ["ACCEL_SL", "ACCEL_10K", "ACCEL_20K"]:
        if test_name in variant_results:
            r = variant_results[test_name]
            lines.append("-" * 70)
            lines.append(f"{test_name} - Level Acceleration (50% Fuel, with AB)")
            lines.append("-" * 70)
            lines.append(f"  Max Speed Achieved: {r.max_spd_kt:.1f} kt")
            lines.extend(format_fuel_info(r))
            if r.speed_gates:
                lines.append("  Speed Gates:")
                for gate in sorted(r.speed_gates, key=lambda g: g.gate_kt):
                    lines.append(
                        f"    {gate.gate_kt:.0f} kt at t={gate.elapsed_s:.1f}s"
                    )
            lines.append("")

    # Turn tests
    for speed in [300, 350, 400]:
        test_name = f"TURN_10K_{speed}"
        if test_name in variant_results:
            r = variant_results[test_name]
            lines.append("-" * 70)
            lines.append(f"{test_name} - Sustained Turn at 10,000 ft (50% Fuel)")
            lines.append("-" * 70)
            lines.append(f"  Target Speed: {speed} kt")
            lines.append(f"  Max Speed:    {r.max_spd_kt:.1f} kt")
            lines.extend(format_fuel_info(r))
            lines.append("")

    # ===== NEW TEST PROFILES =====

    # Ceiling test
    if "CEILING_AB_FULL" in variant_results:
        r = variant_results["CEILING_AB_FULL"]
        lines.append("-" * 70)
        lines.append("CEILING_AB_FULL - Service Ceiling Test (Full Fuel, AB)")
        lines.append("-" * 70)
        if r.ceiling_alt_ft:
            target = TARGETS["ceiling_ft"]
            measured = r.ceiling_alt_ft
            passed = check_tolerance(measured, target, TOLERANCE_PCT)
            status = "PASS" if passed else "FAIL"
            all_pass = all_pass and passed
            lines.append(f"  Ceiling Altitude: {measured:,.0f} ft")
            lines.append(f"  Target:           {target:,} ft")
            lines.append(f"  Status:           {status}")
            if r.ceiling_roc_fpm:
                lines.append(f"  Final ROC:        {r.ceiling_roc_fpm:.0f} fpm")
            if r.ceiling_mach:
                lines.append(f"  Mach at Ceiling:  {r.ceiling_mach:.3f}")
        else:
            lines.append(f"  Max Altitude: {r.max_alt_ft:,.0f} ft (ceiling not detected)")
        lines.extend(format_fuel_info(r))
        if r.alt_gates:
            lines.append("  Altitude Gates:")
            for gate in sorted(r.alt_gates, key=lambda g: g.gate_ft):
                lines.append(
                    f"    {gate.gate_ft:,.0f} ft at t={gate.elapsed_s:.1f}s "
                    f"(ROC: {gate.climb_rate_fpm:.0f} fpm)"
                )
        lines.append("")

    # Extended climb from 10K
    if "CLIMB_10K_AB_FULL" in variant_results:
        r = variant_results["CLIMB_10K_AB_FULL"]
        lines.append("-" * 70)
        lines.append("CLIMB_10K_AB_FULL - Extended Climb from 10,000 ft (Full Fuel, AB)")
        lines.append("-" * 70)
        lines.append(f"  Max Climb Rate: {r.max_vspd_fpm:.0f} fpm")
        lines.append(f"  Max Altitude:   {r.max_alt_ft:,.0f} ft")
        lines.extend(format_fuel_info(r))
        if r.alt_gates:
            lines.append("  Altitude Gates:")
            for gate in sorted(r.alt_gates, key=lambda g: g.gate_ft):
                lines.append(
                    f"    {gate.gate_ft:,.0f} ft at t={gate.elapsed_s:.1f}s "
                    f"(ROC: {gate.climb_rate_fpm:.0f} fpm)"
                )
        lines.append("")

    # Fuel state Vmax tests
    for test_name in ["VMAX_SL_100F", "VMAX_SL_25F"]:
        if test_name in variant_results:
            r = variant_results[test_name]
            fuel_pct = "100%" if "100F" in test_name else "25%"
            lines.append("-" * 70)
            lines.append(f"{test_name} - Max Speed at SL ({fuel_pct} Fuel, AB)")
            lines.append("-" * 70)
            measured = r.vmax_kt or r.max_spd_kt
            lines.append(f"  Measured: {measured:.1f} kt")
            if r.vmax_mach:
                lines.append(f"  Mach:     {r.vmax_mach:.3f}")
            lines.extend(format_fuel_info(r))
            lines.append("")

    # MIL power Vmax
    if "VMAX_10K_MIL" in variant_results:
        r = variant_results["VMAX_10K_MIL"]
        lines.append("-" * 70)
        lines.append("VMAX_10K_MIL - Max Speed at 10,000 ft (MIL Power, No AB)")
        lines.append("-" * 70)
        measured = r.vmax_kt or r.max_spd_kt
        lines.append(f"  Measured: {measured:.1f} kt")
        if r.vmax_mach:
            lines.append(f"  Mach:     {r.vmax_mach:.3f}")
        lines.extend(format_fuel_info(r))
        lines.append("")

    # Deceleration tests
    for test_name in ["DECEL_SL", "DECEL_10K_IDLE"]:
        if test_name in variant_results:
            r = variant_results[test_name]
            alt_desc = "SL" if "SL" in test_name else "10,000 ft"
            lines.append("-" * 70)
            lines.append(f"{test_name} - Deceleration at {alt_desc}")
            lines.append("-" * 70)
            lines.append(f"  Max Speed: {r.max_spd_kt:.1f} kt")
            lines.extend(format_fuel_info(r))
            if r.speed_gates:
                lines.append("  Speed Gates:")
                for gate in sorted(r.speed_gates, key=lambda g: -g.gate_kt):
                    lines.append(
                        f"    {gate.gate_kt:.0f} kt at t={gate.elapsed_s:.1f}s"
                    )
            lines.append("")

    return lines, all_pass


def generate_report(results: dict[str, dict[str, GroupResult]]) -> str:
    """Generate a verification report comparing results to targets."""
    lines: list[str] = []
    lines.append("=" * 70)
    lines.append("MiG-17F Flight Model Test Report")
    lines.append("=" * 70)
    lines.append("")

    # Historical targets
    lines.append("Historical Performance Targets:")
    lines.append(f"  Vmax at SL:    {TARGETS['vmax_sl_kt']} kt (1100 km/h, Mach 0.89)")
    lines.append(f"  Vmax at 10K:   {TARGETS['vmax_10k_kt']} kt (1145 km/h, Mach 0.93)")
    lines.append(f"  Rate of Climb: {TARGETS['roc_fpm']} fpm (65 m/s)")
    lines.append(f"  Ceiling:       {TARGETS['ceiling_ft']} ft")
    lines.append(f"  Tolerance:     Â±{TOLERANCE_PCT}%")
    lines.append("")
    lines.append("Aircraft Specifications (MiG-17F with VK-1F engine):")
    lines.append(f"  Empty weight:      {MIG17_SPECS['empty_kg']:,} kg")
    lines.append(f"  Nominal weight:    {MIG17_SPECS['nominal_kg']:,} kg (full internal fuel)")
    lines.append(f"  Internal fuel:     {MIG17_SPECS['fuel_max_kg']:,} kg")
    lines.append(f"  Military thrust:   {MIG17_SPECS['thrust_mil_kgf']:,} kgf")
    lines.append(f"  Afterburner thrust:{MIG17_SPECS['thrust_ab_kgf']:,} kgf (1.28x)")
    lines.append(f"  AB fuel ratio:     {MIG17_SPECS['fuel_ratio_ab']}x military")

    # Sort variants for consistent output
    sorted_variants = sorted(results.keys())
    num_variants = len(sorted_variants)

    if num_variants > 1:
        lines.append("")
        lines.append(f"Multi-FM Mode: {num_variants} variants detected")
        lines.append(f"Variants: {', '.join(sorted_variants)}")

    all_pass = True

    for variant_key in sorted_variants:
        variant_results = results[variant_key]
        section_lines, section_pass = generate_variant_section(variant_key, variant_results)
        lines.extend(section_lines)
        all_pass = all_pass and section_pass

    # Overall result
    lines.append("")
    lines.append("=" * 70)
    overall = "PASS" if all_pass else "FAIL"
    lines.append(f"OVERALL RESULT: {overall}")
    lines.append("=" * 70)

    return "\n".join(lines)


def write_csv(
    results: dict[str, dict[str, GroupResult]],
    csv_path: Path,
) -> None:
    """Write results to a CSV file with variant and test columns."""
    fieldnames = [
        "variant",
        "test",
        "group_name",
        "max_spd_kt",
        "max_alt_ft",
        "max_vspd_fpm",
        "vmax_kt",
        "vmax_mach",
        "ceiling_alt_ft",
        "ceiling_roc_fpm",
        "ceiling_mach",
        "start_fuel_kg",
        "end_fuel_kg",
        "fuel_used_kg",
    ]

    rows = []
    for variant_key in sorted(results.keys()):
        variant_results = results[variant_key]
        for test_name in sorted(variant_results.keys()):
            r = variant_results[test_name]
            rows.append({
                "variant": variant_key,
                "test": test_name,
                "group_name": r.name,
                "max_spd_kt": f"{r.max_spd_kt:.1f}" if r.max_spd_kt else "",
                "max_alt_ft": f"{r.max_alt_ft:.0f}" if r.max_alt_ft else "",
                "max_vspd_fpm": f"{r.max_vspd_fpm:.0f}" if r.max_vspd_fpm else "",
                "vmax_kt": f"{r.vmax_kt:.1f}" if r.vmax_kt else "",
                "vmax_mach": f"{r.vmax_mach:.3f}" if r.vmax_mach else "",
                "ceiling_alt_ft": f"{r.ceiling_alt_ft:.0f}" if r.ceiling_alt_ft else "",
                "ceiling_roc_fpm": f"{r.ceiling_roc_fpm:.0f}" if r.ceiling_roc_fpm else "",
                "ceiling_mach": f"{r.ceiling_mach:.3f}" if r.ceiling_mach else "",
                "start_fuel_kg": f"{r.start_fuel_kg:.0f}" if r.start_fuel_kg else "",
                "end_fuel_kg": f"{r.end_fuel_kg:.0f}" if r.end_fuel_kg else "",
                "fuel_used_kg": f"{r.fuel_used_kg:.0f}" if r.fuel_used_kg else "",
            })

    with csv_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(rows)

    LOGGER.info("CSV written to: %s", csv_path)


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Parse DCS log for MiG-17 FM test results"
    )
    parser.add_argument(
        "--log-file",
        type=Path,
        help="Path to DCS log file (auto-detected if not specified)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Path to write report (prints to stdout if not specified)",
    )
    parser.add_argument(
        "--csv",
        type=Path,
        help="Path to write CSV output with variant and test columns",
    )
    return parser.parse_args()


def main() -> int:
    """Main entry point."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(levelname)s: %(message)s",
    )

    args = parse_args()

    # Find log file
    log_path = args.log_file
    if not log_path:
        log_path = find_dcs_log()
        if not log_path:
            LOGGER.error("Could not find DCS log file. Use --log-file to specify.")
            return 1

    if not log_path.exists():
        LOGGER.error("Log file not found: %s", log_path)
        return 1

    LOGGER.info("Parsing log file: %s", log_path)

    # Parse and analyze
    results = parse_log_file(log_path)

    if not results:
        LOGGER.warning("No MIG17_FM_TEST data found in log file")
        LOGGER.info("Run the FM test mission in DCS first, then parse the log")
        return 2

    # Count total test groups
    total_groups = sum(len(variant_results) for variant_results in results.values())
    num_variants = len(results)
    LOGGER.info(
        "Found data for %d test groups across %d variant(s)",
        total_groups,
        num_variants,
    )
    for variant_key in sorted(results.keys()):
        LOGGER.info("  %s: %d tests", variant_key, len(results[variant_key]))

    # Generate report
    report = generate_report(results)

    # Output
    if args.output:
        args.output.write_text(report, encoding="utf-8")
        LOGGER.info("Report written to: %s", args.output)
    else:
        print(report)

    # CSV output
    if args.csv:
        write_csv(results, args.csv)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
