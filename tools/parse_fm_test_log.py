"""Parse DCS log file for MiG-17 flight model test results.

This script extracts and analyzes data from the [MIG17_FM_TEST] log entries
generated by the FM test mission. It compares measured performance against
historical MiG-17F targets and generates a verification report.

Usage:
    python parse_fm_test_log.py [--log-file PATH] [--output PATH]

If --log-file is not specified, searches common DCS log locations.
"""
from __future__ import annotations

import argparse
import logging
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional

LOGGER = logging.getLogger(__name__)

# Historical MiG-17F performance targets
TARGETS = {
    "vmax_sl_kt": 593,      # Max speed at sea level (1100 km/h)
    "vmax_10k_kt": 618,     # Max speed at 10,000 ft with AB (1145 km/h)
    "roc_fpm": 12800,       # Rate of climb (65 m/s)
    "ceiling_ft": 54500,    # Service ceiling
}

# MiG-17F weight and fuel specifications (from mig17f.lua)
MIG17_SPECS = {
    "empty_kg": 3920,       # Empty weight with pilot (M_empty)
    "nominal_kg": 5345,     # Empty + full internal fuel (M_nominal)
    "max_kg": 6075,         # Maximum takeoff weight (M_max)
    "fuel_max_kg": 1140,    # Internal fuel capacity (M_fuel_max)
    "thrust_mil_kgf": 2650,     # Military power thrust
    "thrust_ab_kgf": 3380,      # Afterburner thrust
    "fuel_ratio_ab": 2.06,      # Afterburner fuel consumption ratio vs military
}

# Acceptable tolerance for pass/fail (percentage)
TOLERANCE_PCT = 5.0


@dataclass
class SpeedGate:
    """Record of crossing a speed gate."""

    gate_kt: float
    elapsed_s: float
    alt_ft: float


@dataclass
class AltGate:
    """Record of crossing an altitude gate."""

    gate_ft: float
    elapsed_s: float
    climb_rate_fpm: float


@dataclass
class GroupResult:
    """Collected results for a single test group."""

    name: str
    start_alt_ft: float = 0
    start_spd_kt: float = 0
    max_spd_kt: float = 0
    max_alt_ft: float = 0
    max_vspd_fpm: float = 0
    speed_gates: list[SpeedGate] = field(default_factory=list)
    alt_gates: list[AltGate] = field(default_factory=list)
    vmax_kt: Optional[float] = None
    vmax_alt_ft: Optional[float] = None
    vmax_mach: Optional[float] = None
    # Fuel tracking
    start_fuel_kg: Optional[float] = None
    start_fuel_pct: Optional[float] = None
    start_weight_kg: Optional[float] = None
    end_fuel_kg: Optional[float] = None
    fuel_used_kg: Optional[float] = None


def find_dcs_log() -> Optional[Path]:
    """Search common locations for the DCS log file."""
    candidates = [
        Path.home() / "Saved Games" / "DCS" / "Logs" / "dcs.log",
        Path.home() / "Saved Games" / "DCS.openbeta" / "Logs" / "dcs.log",
        Path.home() / "Saved Games" / "DCS.release_server" / "Logs" / "dcs.log",
    ]
    for path in candidates:
        if path.exists():
            return path
    return None


def parse_log_file(log_path: Path) -> dict[str, GroupResult]:
    """Parse the DCS log file and extract FM test data."""
    results: dict[str, GroupResult] = {}
    pattern = re.compile(r"\[MIG17_FM_TEST\]\s+(.+)")

    content = log_path.read_text(encoding="utf-8", errors="ignore")

    for line in content.splitlines():
        match = pattern.search(line)
        if not match:
            continue

        data = match.group(1).strip()

        # Parse START lines: START,<group>,alt=<alt>,spd=<spd>[,fuel_kg=,fuel_pct=,weight_kg=]
        if data.startswith("START,"):
            parts = data.split(",")
            if len(parts) >= 2:
                group_name = parts[1]
                if group_name not in results:
                    results[group_name] = GroupResult(name=group_name)
                # Extract fields from key=value pairs
                for part in parts[2:]:
                    if part.startswith("alt="):
                        results[group_name].start_alt_ft = float(part[4:])
                    elif part.startswith("spd="):
                        results[group_name].start_spd_kt = float(part[4:])
                    elif part.startswith("fuel_kg="):
                        results[group_name].start_fuel_kg = float(part[8:])
                    elif part.startswith("fuel_pct="):
                        results[group_name].start_fuel_pct = float(part[9:])
                    elif part.startswith("weight_kg="):
                        results[group_name].start_weight_kg = float(part[10:])

        # Parse SPEED_GATE lines: SPEED_GATE,<group>,<gate_kt>,<elapsed_s>,<alt_ft>
        elif data.startswith("SPEED_GATE,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in results:
                    results[group_name] = GroupResult(name=group_name)
                gate = SpeedGate(
                    gate_kt=float(parts[2]),
                    elapsed_s=float(parts[3]),
                    alt_ft=float(parts[4]),
                )
                results[group_name].speed_gates.append(gate)

        # Parse ALT_GATE lines: ALT_GATE,<group>,<gate_ft>,<elapsed_s>,<climb_rate_fpm>
        elif data.startswith("ALT_GATE,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in results:
                    results[group_name] = GroupResult(name=group_name)
                gate = AltGate(
                    gate_ft=float(parts[2]),
                    elapsed_s=float(parts[3]),
                    climb_rate_fpm=float(parts[4]),
                )
                results[group_name].alt_gates.append(gate)

        # Parse VMAX lines: VMAX,<group>,<speed_kt>,<alt_ft>,<mach>
        elif data.startswith("VMAX,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in results:
                    results[group_name] = GroupResult(name=group_name)
                results[group_name].vmax_kt = float(parts[2])
                results[group_name].vmax_alt_ft = float(parts[3])
                results[group_name].vmax_mach = float(parts[4])

        # Parse SUMMARY lines: SUMMARY,<group>,<max_spd>,<max_alt>,<max_vspd>[,fuel_start=,fuel_end=,fuel_used=]
        elif data.startswith("SUMMARY,"):
            parts = data.split(",")
            if len(parts) >= 5:
                group_name = parts[1]
                if group_name not in results:
                    results[group_name] = GroupResult(name=group_name)
                results[group_name].max_spd_kt = float(parts[2])
                results[group_name].max_alt_ft = float(parts[3])
                results[group_name].max_vspd_fpm = float(parts[4])
                # Parse optional fuel fields
                for part in parts[5:]:
                    if part.startswith("fuel_start="):
                        results[group_name].start_fuel_kg = float(part[11:])
                    elif part.startswith("fuel_end="):
                        results[group_name].end_fuel_kg = float(part[9:])
                    elif part.startswith("fuel_used="):
                        results[group_name].fuel_used_kg = float(part[10:])

    return results


def check_tolerance(measured: float, target: float, tolerance_pct: float) -> bool:
    """Check if measured value is within tolerance of target."""
    if target == 0:
        return measured == 0
    deviation_pct = abs(measured - target) / target * 100
    return deviation_pct <= tolerance_pct


def format_fuel_info(result: GroupResult) -> list[str]:
    """Format fuel information for a test result."""
    lines: list[str] = []
    if result.start_fuel_kg is not None:
        lines.append(f"  Start fuel:   {result.start_fuel_kg:.0f} kg")
        if result.start_fuel_pct is not None:
            lines[-1] += f" ({result.start_fuel_pct:.0f}%)"
    if result.start_weight_kg is not None:
        lines.append(f"  Start weight: {result.start_weight_kg:.0f} kg")
    if result.fuel_used_kg is not None and result.fuel_used_kg > 0:
        lines.append(f"  Fuel used:    {result.fuel_used_kg:.0f} kg")
    return lines


def generate_report(results: dict[str, GroupResult]) -> str:
    """Generate a verification report comparing results to targets."""
    lines: list[str] = []
    lines.append("=" * 70)
    lines.append("MiG-17F Flight Model Test Report")
    lines.append("=" * 70)
    lines.append("")

    # Historical targets
    lines.append("Historical Performance Targets:")
    lines.append(f"  Vmax at SL:    {TARGETS['vmax_sl_kt']} kt (1100 km/h, Mach 0.89)")
    lines.append(f"  Vmax at 10K:   {TARGETS['vmax_10k_kt']} kt (1145 km/h, Mach 0.93)")
    lines.append(f"  Rate of Climb: {TARGETS['roc_fpm']} fpm (65 m/s)")
    lines.append(f"  Ceiling:       {TARGETS['ceiling_ft']} ft")
    lines.append(f"  Tolerance:     Â±{TOLERANCE_PCT}%")
    lines.append("")
    lines.append("Aircraft Specifications (MiG-17F with VK-1F engine):")
    lines.append(f"  Empty weight:      {MIG17_SPECS['empty_kg']:,} kg")
    lines.append(f"  Nominal weight:    {MIG17_SPECS['nominal_kg']:,} kg (full internal fuel)")
    lines.append(f"  Internal fuel:     {MIG17_SPECS['fuel_max_kg']:,} kg")
    lines.append(f"  Military thrust:   {MIG17_SPECS['thrust_mil_kgf']:,} kgf")
    lines.append(f"  Afterburner thrust:{MIG17_SPECS['thrust_ab_kgf']:,} kgf (1.28x)")
    lines.append(f"  AB fuel ratio:     {MIG17_SPECS['fuel_ratio_ab']}x military")
    lines.append("")

    all_pass = True

    # Vmax at sea level
    lines.append("-" * 70)
    lines.append("VMAX_SL - Maximum Speed at Sea Level")
    lines.append("-" * 70)
    if "VMAX_SL" in results:
        r = results["VMAX_SL"]
        measured = r.vmax_kt or r.max_spd_kt
        target = TARGETS["vmax_sl_kt"]
        passed = check_tolerance(measured, target, TOLERANCE_PCT)
        status = "PASS" if passed else "FAIL"
        all_pass = all_pass and passed
        lines.append(f"  Measured: {measured:.1f} kt")
        lines.append(f"  Target:   {target} kt")
        lines.append(f"  Status:   {status}")
        if r.vmax_mach:
            lines.append(f"  Mach:     {r.vmax_mach:.3f}")
        lines.extend(format_fuel_info(r))
    else:
        lines.append("  No data available")
        all_pass = False
    lines.append("")

    # Vmax at 10,000 ft
    lines.append("-" * 70)
    lines.append("VMAX_10K - Maximum Speed at 10,000 ft (with Afterburner)")
    lines.append("-" * 70)
    if "VMAX_10K" in results:
        r = results["VMAX_10K"]
        measured = r.vmax_kt or r.max_spd_kt
        target = TARGETS["vmax_10k_kt"]
        passed = check_tolerance(measured, target, TOLERANCE_PCT)
        status = "PASS" if passed else "FAIL"
        all_pass = all_pass and passed
        lines.append(f"  Measured: {measured:.1f} kt")
        lines.append(f"  Target:   {target} kt")
        lines.append(f"  Status:   {status}")
        if r.vmax_mach:
            lines.append(f"  Mach:     {r.vmax_mach:.3f}")
        lines.extend(format_fuel_info(r))
    else:
        lines.append("  No data available")
        all_pass = False
    lines.append("")

    # Rate of climb
    lines.append("-" * 70)
    lines.append("CLIMB_SL - Rate of Climb from Sea Level (Full Fuel, with AB)")
    lines.append("-" * 70)
    if "CLIMB_SL" in results:
        r = results["CLIMB_SL"]
        measured = r.max_vspd_fpm
        target = TARGETS["roc_fpm"]
        passed = check_tolerance(measured, target, TOLERANCE_PCT)
        status = "PASS" if passed else "FAIL"
        all_pass = all_pass and passed
        lines.append(f"  Max Climb Rate: {measured:.0f} fpm")
        lines.append(f"  Target:         {target} fpm")
        lines.append(f"  Status:         {status}")
        lines.extend(format_fuel_info(r))
        # Show altitude gates
        if r.alt_gates:
            lines.append("  Altitude Gates:")
            for gate in sorted(r.alt_gates, key=lambda g: g.gate_ft):
                lines.append(
                    f"    {gate.gate_ft:,.0f} ft at t={gate.elapsed_s:.1f}s "
                    f"(ROC: {gate.climb_rate_fpm:.0f} fpm)"
                )
    else:
        lines.append("  No data available")
        all_pass = False
    lines.append("")

    # Acceleration tests
    for group_name in ["ACCEL_SL", "ACCEL_10K", "ACCEL_20K"]:
        if group_name in results:
            r = results[group_name]
            lines.append("-" * 70)
            lines.append(f"{group_name} - Level Acceleration (50% Fuel, with AB)")
            lines.append("-" * 70)
            lines.append(f"  Max Speed Achieved: {r.max_spd_kt:.1f} kt")
            lines.extend(format_fuel_info(r))
            if r.speed_gates:
                lines.append("  Speed Gates:")
                for gate in sorted(r.speed_gates, key=lambda g: g.gate_kt):
                    lines.append(
                        f"    {gate.gate_kt:.0f} kt at t={gate.elapsed_s:.1f}s"
                    )
            lines.append("")

    # Turn tests
    for speed in [300, 350, 400]:
        group_name = f"TURN_10K_{speed}"
        if group_name in results:
            r = results[group_name]
            lines.append("-" * 70)
            lines.append(f"{group_name} - Sustained Turn at 10,000 ft (50% Fuel)")
            lines.append("-" * 70)
            lines.append(f"  Target Speed: {speed} kt")
            lines.append(f"  Max Speed:    {r.max_spd_kt:.1f} kt")
            lines.extend(format_fuel_info(r))
            lines.append("")

    # Overall result
    lines.append("=" * 70)
    overall = "PASS" if all_pass else "FAIL"
    lines.append(f"OVERALL RESULT: {overall}")
    lines.append("=" * 70)

    return "\n".join(lines)


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Parse DCS log for MiG-17 FM test results"
    )
    parser.add_argument(
        "--log-file",
        type=Path,
        help="Path to DCS log file (auto-detected if not specified)",
    )
    parser.add_argument(
        "--output",
        type=Path,
        help="Path to write report (prints to stdout if not specified)",
    )
    return parser.parse_args()


def main() -> int:
    """Main entry point."""
    logging.basicConfig(
        level=logging.INFO,
        format="%(levelname)s: %(message)s",
    )

    args = parse_args()

    # Find log file
    log_path = args.log_file
    if not log_path:
        log_path = find_dcs_log()
        if not log_path:
            LOGGER.error("Could not find DCS log file. Use --log-file to specify.")
            return 1

    if not log_path.exists():
        LOGGER.error("Log file not found: %s", log_path)
        return 1

    LOGGER.info("Parsing log file: %s", log_path)

    # Parse and analyze
    results = parse_log_file(log_path)

    if not results:
        LOGGER.warning("No MIG17_FM_TEST data found in log file")
        LOGGER.info("Run the FM test mission in DCS first, then parse the log")
        return 2

    LOGGER.info("Found data for %d test groups", len(results))

    # Generate report
    report = generate_report(results)

    # Output
    if args.output:
        args.output.write_text(report, encoding="utf-8")
        LOGGER.info("Report written to: %s", args.output)
    else:
        print(report)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
